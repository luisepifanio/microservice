/*
 * This build file was auto generated by running the Gradle 'init' task
 * by 'luis' at '21/01/17 20:51' with Gradle 3.1
 *
 * This generated file contains a sample Java project to get you started.
 * For more details take a look at the Java Quickstart chapter in the Gradle
 * user guide available at https://docs.gradle.org/3.1/userguide/tutorial_java_projects.html
 */
buildscript {

    repositories {
        mavenCentral()
        // jcenter()
    }

    dependencies {
        // classpath 'ru.alfalab.gradle:cucumber-reporting-gradle-plugin:x.x.+'
        classpath 'com.github.tomakehurst:wiremock:2.5.1'
    }
}


import com.github.tomakehurst.wiremock.WireMockServer
import com.github.tomakehurst.wiremock.common.ConsoleNotifier

import static com.github.tomakehurst.wiremock.core.WireMockConfiguration.wireMockConfig

plugins {
    // Apply the java plugin to add support for Java
    id "java"
    // Apply the groovy plugin to also add support for Groovy (needed for Spock)
    id 'groovy'
    // Apply the jacoco plugin to add support for code coverage
    id 'jacoco'
    //  ???
    id "application"
    // Fat Jar
    id "com.github.johnrengelman.shadow" version "1.2.4"
    // use IntellJ :)
    id 'idea'
    // Cucumber reporting
    // id 'ru.alfalab.cucumber-reporting'
    // JMeter integration
    id "net.foragerr.jmeter" version "1.0.7-3.0-BETA"
}

// Tell Boutique where to begin
mainClassName = "application.Application"
group "ar.com.phosgenos.bootique.demo"
version "0.1"


shadowJar {
    mergeServiceFiles()
}
//Local variables
String OPT_DIR = "${buildDir}/opt"
String OPT_CONF = "${OPT_DIR}/conf"

WireMockServer wireMockServer
int wmPort =  9080
int wmHttpsPort = 9443
String usingFilesUnderClasspath = './mockserver'

//Source and target compatibility
sourceCompatibility = 1.8
targetCompatibility = 1.8

// In this section you declare where to find the dependencies of your project
repositories {
    // Maven usage
    mavenLocal()
    // Use Maven Central for resolving your dependencies.
    mavenCentral()
    // Use 'jcenter' for resolving your dependencies.
    // You can declare any Maven/Ivy/file repository here.
    jcenter()
}

// In this section you declare the dependencies for your production and test code
dependencies {
    ////////// LOGGING
    // The production code uses the SLF4J logging API at compile time
    compile 'org.slf4j:slf4j-api:1.7.21'

    //REACTIVE SUPPORT
    // Just using java
    // compile 'io.reactivex.rxjava2:rxjava:2.0.4'
    // Using java and groovy
    // compile 'io.reactivex:rxgroovy:1.0.3'

    // Great way to avoid boilerplate code in pure Java
    compileOnly "org.projectlombok:lombok:1.16.14"

    //Bootique
    compile 'io.bootique:bootique:0.22'
    compile 'io.bootique.logback:bootique-logback:0.14'
    compile 'io.bootique.jersey:bootique-jersey:0.21'

    //Bootique swagger integration,have to annotate yur classes to document
    compile 'io.bootique.swagger:bootique-swagger:0.3'
    // Can we have a decent json mapper
    compile 'org.glassfish.jersey.media:jersey-media-json-jackson:2.25.1'
    //compile 'com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider:2.8.8'

    //Database
    compile 'com.h2database:h2:1.4.194'
    // Database integration
    compile 'io.bootique.jdbc:bootique-jdbc:0.14'
    //MyBatis
    // compile 'org.mybatis:mybatis:3.4.4'

    // External http client
    // compile 'com.squareup.okhttp3:okhttp:3.6.0'

    // Experimental FIQL please remove trashy dependencies
    compile 'org.apache.cxf:cxf-rt-rs-extension-search:3.1.11'



    ////////// TESTING RELATED
    // We use the latest groovy 2.x version for Spock testing
    compile 'org.codehaus.groovy:groovy-all:2.4.7'

    // Use the awesome Spock testing and specification framework even with Java
    testCompile 'org.spockframework:spock-core:1.0-groovy-2.4'
    testCompile 'junit:junit:4.12'

    // optional dependencies for using Spock
    testCompile "org.hamcrest:hamcrest-core:1.3" // only necessary if Hamcrest matchers are used
    testRuntime "cglib:cglib-nodep:3.1"          // allows mocking of classes (in addition to interfaces)
    testRuntime "org.objenesis:objenesis:2.1"    // allows mocking of classes without default constructor (together with CGLIB)

    //Functional tests support
    testCompile 'io.rest-assured:rest-assured:3.0.2'

    //Aceptance test
    testCompile 'info.cukes:cucumber-junit:1.2.5'
    testCompile 'info.cukes:cucumber-groovy:1.2.5'

}

apply from: "gradle/ide.gradle"

//Jacoco Repo
jacoco {
    toolVersion = '0.7.9'
}

jacocoTestReport {
    reports {
        xml.enabled false
        csv.enabled false
        html{
            enabled true
            destination "${buildDir}/reports/coverage"
        }
    }
    executionData files([
            "$buildDir/jacoco/test.exec",
            "$buildDir/jacoco/integration.exec",
            "$buildDir/jacoco/functional.exec",
            "$buildDir/jacoco/aceptance.exec"
    ])
}

// cucumberReporting {
//     cucumberResultsDirectory = file("${project.buildDir}/cucumber") // cucumber results dir (eg. cucumber.json location)
//     outputDirectory = file("${project.buildDir}/reports/cucumber") // directory for save html reports
// }

sourceSets {
    main {
        output.resourcesDir = "build/classes/main"
        groovy {
            srcDirs = ['src/main/groovy']
        }
        java {
            srcDirs = ['src/main/java']
        }
    }

    test {
        output.resourcesDir = "build/classes/test"
        groovy {
            srcDirs = ['src/test/unit/groovy']
        }
        java {
            srcDirs = ['src/test/unit/java']
        }
        resources {
            srcDirs = ['src/test/unit/resources']
        }
    }

    integration {
        output.resourcesDir = 'build/classes/integration'
        groovy {
            srcDirs = ['src/test/integration/groovy']
        }
        java {
            srcDirs = ['src/test/integration/java']
        }
        resources {
            srcDirs = ['src/test/integration/resources']
        }
        //compileClasspath += sourceSets.main.output + configurations.testCompile
        compileClasspath += sourceSets.main.runtimeClasspath
        runtimeClasspath += main.output + compileClasspath + configurations.testRuntime
    }
    functional {
        output.resourcesDir = 'build/classes/functional'
        groovy {
            srcDirs = ['src/test/functional/groovy']
        }
        java {
            srcDirs = ['src/test/functional/java']
        }
        resources {
            srcDirs = ['src/test/functional/resources']
        }
        compileClasspath += sourceSets.main.output + configurations.testCompile
        runtimeClasspath += main.output + compileClasspath + configurations.testRuntime
    }

    aceptance {
        output.resourcesDir = 'build/classes/aceptance'
        groovy {
            srcDirs = ['src/test/aceptance/groovy']
        }
        java {
            srcDirs = ['src/test/aceptance/java']
        }
        resources {
            srcDirs = ['src/test/aceptance/resources']
        }
        compileClasspath += sourceSets.main.output + configurations.testCompile
        runtimeClasspath += main.output + compileClasspath + configurations.testRuntime
    }
}

test {
    workingDir = "build/classes/test"
    testLogging {
        // Make sure output from
        // standard out or error is shown
        // in Gradle output.
        showStandardStreams = true
        // Or we use events method:
        // events 'standard_out', 'standard_error'

        // Or set property events:
        // events = ['standard_out', 'standard_error']

        // set options for log level DEBUG
        debug {
            events "started", "skipped", "failed"
            exceptionFormat "full"
        }

        // Instead of string values we can
        // use enum values:
        // events org.gradle.api.tasks.testing.logging.TestLogEvent.STANDARD_OUT,
        //        org.gradle.api.tasks.testing.logging.TestLogEvent.STANDARD_ERROR,
    }

    afterTest { desc, result ->
        println "Executing test [${desc.className}].${desc.name} with result: ${result.resultType}"
    }
}

configurations {
    integrationCompile.extendsFrom testCompile
    integrationRuntime.extendsFrom testRuntime

    functionalCompile.extendsFrom testCompile
    functionalRuntime.extendsFrom testRuntime

    aceptanceCompile.extendsFrom testCompile
    aceptanceRuntime.extendsFrom testRuntime
}

//// Tasks
task wrapper(type: Wrapper) {
    gradleVersion = '3.3'
}

task initSourceFolders {
  doLast {
    sourceSets*.java.srcDirs*.each { it.mkdirs() }
    sourceSets*.groovy.srcDirs*.each { it.mkdirs() }
    sourceSets*.resources.srcDirs*.each { it.mkdirs() }
  }
}

task integration(type: Test, group: 'verification', description: 'Runs all integration tests.') {
    testClassesDir  = sourceSets.integration.output.classesDir
    classpath       += sourceSets.integration.runtimeClasspath

    reports.html.destination = file("${reports.html.destination}/integration")
    reports.junitXml.destination = file("${reports.junitXml.destination}/integration")
}

task functional(type: Test, group: 'verification', description: 'Runs all integration tests.') {
    testClassesDir  = sourceSets.functional.output.classesDir
    classpath       = sourceSets.functional.runtimeClasspath

    reports.html.destination = file("${reports.html.destination}/functional")
    reports.junitXml.destination = file("${reports.junitXml.destination}/functional")
}

task aceptance(type: Test, group: 'verification', description: 'Runs all aceptance tests.') {

    testClassesDir  = sourceSets.aceptance.output.classesDir
    classpath       = sourceSets.aceptance.runtimeClasspath

    reports.html.destination = file("${reports.html.destination}/aceptance")
    reports.junitXml.destination = file("${reports.junitXml.destination}/aceptance")

    dependsOn assemble, compileTestJava, compileTestGroovy

    doLast {
        javaexec {
            main = "cucumber.api.cli.Main"
            classpath = configurations.aceptanceRuntime + sourceSets.main.output + sourceSets.test.output
            args = [
                '--glue', 'src/test/aceptance/groovy',
                'src/test/aceptance/resources/features'
            ]
        }
    }
}

task appstructure {
    doLast {
        def directories = [
                OPT_DIR,
                "$OPT_DIR/libs",
                "$OPT_DIR/db",
                OPT_CONF
        ]
        directories.each { new File(it).mkdirs() }
    }
}

task copypackedapp(type: Copy) {
    from "${buildDir}/libs/${rootProject.name}-${version}-all.jar"
    into "$OPT_DIR/libs"
}

task copyconfiguration(type: Copy) {
    from "${rootDir}/conf"
    into "$OPT_CONF"
}

task copydatabase(type: Copy) {
    from "${rootDir}/src/main/resources/db/beerdb2.h2.mv.db"
    into "$OPT_DIR/db"
}

task distribute {
    dependsOn 'shadowJar', 'appstructure','copyconfiguration','copydatabase', 'copypackedapp'
}

task startapp_test(type: ExecWait) {
    command "java -jar ./libs/${rootProject.name}-${version}-all.jar --server --config=conf/test.yaml"
    ready 'Started Jetty in'
    directory "$OPT_DIR"
}

task startapp_dev(type: ExecWait) {
    command "java -jar ./libs/${rootProject.name}-${version}-all.jar --server --config=conf/dev.yaml"
    ready 'Started Jetty in'
    directory "$OPT_DIR"
}

task startwiremock {
    doLast {
        if( wireMockServer ){
            if( wireMockServer.running ){
                wireMockServer.shutdownServer()
                //http://<host>:<port>/__admin/shutdown
            }
        }else{

            wireMockServer = new WireMockServer(
                    wireMockConfig()
                            .port(wmPort)
                            .httpsPort(wmHttpsPort)
                            .usingFilesUnderClasspath(usingFilesUnderClasspath)
                            //.withRootDirectory(usingFilesUnderClasspath)
                            //.usingFilesUnderDirectory("$usingFilesUnderClasspath/__files")
                            .notifier(new ConsoleNotifier(true))
            ) //No-args constructor will start on port 8080, no HTTPS
            wireMockServer.start()
        }
        println wireMockServer
    }
}

task stopwiremock {
    doLast {
        if( wireMockServer ){
            wireMockServer.shutdownServer()
        }
    }
}


task freeallports {
    doLast {
        println 'Executing freeallports'
        List<Integer> ports = [ 8080 ]

        ports.each { Integer port ->
            String cmd = "lsof -Fp -i :$port"
            Process process = new ProcessBuilder(cmd.split(' '))
                    .directory(file("$OPT_DIR"))
                    .redirectErrorStream(true)
                    .start()
            InputStream stdout = process.getInputStream()
            BufferedReader reader = new BufferedReader(new InputStreamReader(stdout))

            String line
            List<String> processes = []
            while ((line = reader.readLine()) != null) {
                processes << line.substring(1)
            }
            processes.each {
                println "Killing $it"
                Process killProcess = new ProcessBuilder("kill -9 $it".split(' '))
                        .directory(file("$OPT_DIR"))
                        .redirectErrorStream(true)
                        .start()
                killProcess.waitFor()
            }
        }
    }
}

check.dependsOn integration
check.dependsOn functional
check.dependsOn aceptance
startapp_dev.dependsOn distribute

integration.mustRunAfter test
functional.mustRunAfter integration
aceptance.mustRunAfter functional

copypackedapp.mustRunAfter shadowJar

build.dependsOn jacocoTestReport
test.dependsOn distribute

gradle.addListener( new TestLifecycleListener() )

/////////

class ExecWait extends DefaultTask {
    String command
    String ready
    String directory

    @TaskAction
    def spawnProcess() {

        Process process = new ProcessBuilder(command.split(' '))
                                    .redirectErrorStream(true)
                                    .directory(new File(directory))
                                    .start()

        InputStream standarOutput = process.getInputStream()
        BufferedReader reader = new BufferedReader(new InputStreamReader(standarOutput))

        String line
        while ((line = reader.readLine()) != null) {
            println line
            if (line.contains(ready)) {
                println "$command is ready"
                break;
            }
        }
    }
}

class TestLifecycleListener implements TaskExecutionListener {

    Map<String,Collection<String>> execBefore = [
            integration: [],
            functional : ['startwiremock', 'startapp_test'],
            aceptance  : ['startwiremock', 'startapp_test']
    ]
    Map<String,Collection<String>> execAfter = [
            integration: [],
            functional : ['stopwiremock', 'freeallports'],
            aceptance  : ['stopwiremock', 'freeallports']
    ]

    @Override
    void beforeExecute(Task task) {
        if(execBefore.keySet().contains(task.name) && execBefore[task.name] ){
            println "Before ${task.name} let's execute ${execBefore[task.name]}"
            execBefore[task.name].each {
                task.project.tasks."$it".execute()
            }

        }
    }

    @Override
    void afterExecute(Task task, TaskState taskState) {
        String taskName = 'freeallports'
        if(execAfter.keySet().contains(task.name) && execAfter[task.name] ){
            println "After ${task.name} let's execute ${execAfter[task.name]}"
            execAfter[task.name].each {
                task.project.tasks."$it".execute()
            }
        }
    }

    String describe(Task task){
        "${task.name}:${task.group} : ${task.description}"
    }
}
